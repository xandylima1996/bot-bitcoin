<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bitcoin Bot Chart</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lightweight-charts/4.1.1/lightweight-charts.standalone.production.min.js"></script>
    <style>
        body { background-color: #0d1117; color: #c9d1d9; font-family: sans-serif; margin: 0; padding: 20px; display: flex; flex-direction: column; height: 100vh; }
        h1 { margin: 0 0 10px 0; font-size: 1.5rem; }
        .container { flex: 1; display: flex; flex-direction: column; gap: 20px; }
        #chart-container { flex: 2; border: 1px solid #30363d; border-radius: 8px; overflow: hidden; position: relative; }
        
        #debug-log { 
            font-family: monospace; font-size: 0.8rem; color: #8b949e; 
            background: #161b22; padding: 10px; border-radius: 5px; margin-bottom: 10px; border: 1px solid #30363d;
        }
        .success { color: #2ea043; font-weight: bold; }
        .error { color: #da3633; font-weight: bold; background: rgba(218, 54, 51, 0.1); padding: 2px; }
        .warning { color: #d29922; }
    </style>
</head>
<body>
    <h1>BTC/USD - Gráfico do Robô</h1>
    <div id="debug-log">Carregando...</div>
    <div class="container">
        <div id="chart-container"></div>
    </div>

    <script>
        // Sistema de Log na tela
        function log(msg, type='') {
            const el = document.getElementById('debug-log');
            const time = new Date().toLocaleTimeString();
            el.innerHTML = `<div class="${type}">[${time}] ${msg}</div>` + el.innerHTML;
        }

        // Captura erros globais (se a biblioteca não baixar, ele avisa aqui)
        window.addEventListener('error', function(event) {
            log("ERRO DE SCRIPT: " + event.message, "error");
        });

        // --- 1. CONFIGURAÇÃO E INICIALIZAÇÃO ---
        window.onload = function() {
            try {
                // Verifica se a ferramenta de desenho baixou
                if (!window.LightweightCharts) {
                    throw new Error("A biblioteca LightweightCharts não foi carregada. Verifique sua internet.");
                }
                log("Biblioteca Gráfica carregada com sucesso.", "success");

                const chart = LightweightCharts.createChart(document.getElementById('chart-container'), { 
                    layout: { textColor: '#d1d4dc', background: { type: 'solid', color: '#0d1117' } },
                    grid: { vertLines: { color: '#21262d' }, horzLines: { color: '#21262d' } },
                    timeScale: { timeVisible: true, secondsVisible: false, borderColor: '#30363d' },
                    rightPriceScale: { borderColor: '#30363d' },
                });

                const candleSeries = chart.addCandlestickSeries({ upColor: '#2ea043', downColor: '#da3633', borderVisible: false, wickUpColor: '#2ea043', wickDownColor: '#da3633' });
                const bbUpper = chart.addLineSeries({ color: 'rgba(56, 139, 253, 0.5)', lineWidth: 1 });
                const bbLower = chart.addLineSeries({ color: 'rgba(56, 139, 253, 0.5)', lineWidth: 1 });
                const bbBasis = chart.addLineSeries({ color: 'rgba(210, 153, 34, 0.5)', lineWidth: 1, lineStyle: 2 });

                // --- 2. MATEMÁTICA ---
                function calculateBB(data, period = 20, stdDev = 2) {
                    let result = [];
                    for (let i = 0; i < data.length; i++) {
                        if (i < period - 1) { result.push({ time: data[i].time }); continue; }
                        let slice = data.slice(i - period + 1, i + 1);
                        let sum = slice.reduce((a, b) => a + b.close, 0);
                        let mean = sum / period;
                        let squaredDiffs = slice.map(x => Math.pow(x.close - mean, 2));
                        let std = Math.sqrt(squaredDiffs.reduce((a, b) => a + b, 0) / period);
                        result.push({ time: data[i].time, upper: mean + (std * stdDev), lower: mean - (std * stdDev), basis: mean });
                    }
                    return result;
                }

                // --- 3. DADOS (Backup Automático) ---
                function generateFakeData() {
                    log("Ativando MODO SIMULAÇÃO (Dados Gerados)", "warning");
                    const res = [];
                    let price = 95000;
                    let time = Math.floor(Date.now() / 1000) - (100 * 60);
                    for (let i = 0; i < 100; i++) {
                        const close = price + (Math.random() - 0.5) * 200;
                        res.push({ time: time + (i * 60), open: price, high: Math.max(price, close)+50, low: Math.min(price, close)-50, close: close });
                        price = close;
                    }
                    return res;
                }

                async function start() {
                    let candles = [];
                    try {
                        log("Tentando conectar API CryptoCompare...");
                        const res = await fetch('https://min-api.cryptocompare.com/data/v2/histominute?fsym=BTC&tsym=USD&limit=100');
                        const json = await res.json();
                        
                        if (json.Response !== 'Success') throw new Error("Erro na resposta da API");
                        
                        candles = json.Data.Data.map(d => ({ time: d.time, open: d.open, high: d.high, low: d.low, close: d.close }));
                        log("Conectado: Dados Reais (CryptoCompare)", "success");
                    } catch (e) {
                        log("Falha na API: " + e.message, "error");
                        candles = generateFakeData();
                    }

                    if (candles.length > 0) {
                        candleSeries.setData(candles);
                        const bbData = calculateBB(candles);
                        const validBB = bbData.filter(d => d.upper);
                        bbUpper.setData(validBB.map(d => ({ time: d.time, value: d.upper })));
                        bbLower.setData(validBB.map(d => ({ time: d.time, value: d.lower })));
                        bbBasis.setData(validBB.map(d => ({ time: d.time, value: d.basis })));
                    }
                    
                    // Ajuste de tamanho
                    new ResizeObserver(entries => {
                        if (entries.length === 0) return;
                        const newRect = entries[0].contentRect;
                        chart.applyOptions({ height: newRect.height, width: newRect.width });
                    }).observe(document.getElementById('chart-container'));
                }

                start();

            } catch (fatalError) {
                log("ERRO FATAL: " + fatalError.message, "error");
            }
        };
    </script>
</body>
</html>
